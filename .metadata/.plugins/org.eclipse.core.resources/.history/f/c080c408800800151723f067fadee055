package de.tudarmstadt.informatik.tk.assistanceplatform.modules.hotplaces.data;

import java.util.ArrayDeque;
import java.util.Deque;
import java.util.HashMap;
import java.util.Map;

import de.tudarmstadt.informatik.tk.assistanceplatform.data.GeographicPosition;
import de.tudarmstadt.informatik.tk.assistanceplatform.data.user.UserContext;
import de.tudarmstadt.informatik.tk.assistanceplatform.modules.DataModule;
import de.tudarmstadt.informatik.tk.assistanceplatform.modules.hotplaces.HotPlace;
import de.tudarmstadt.informatik.tk.assistanceplatform.services.messaging.Consumer;
import de.tudarmstadt.informatik.tk.assistanceplatform.services.messaging.MessagingService;
import de.tudarmstadt.informatik.tk.assistanceplatform.services.messaging.MessagingService.Channel;
import de.tudarmstadt.informatik.tk.assistanceplatform.services.messaging.dummy.DummyMessagingService;

/**
 * This module does the data processing for the hot place detections and recommendations.
 * @author bjeutter
 */
public class HotPlacesDataModule extends DataModule {
	private MessagingService messagingService;
	
	private Map<Long, Deque<GeographicPosition>> userTraces = new HashMap<>();
	
	public HotPlacesDataModule() {
		super();
		
		// TODO: Wo die Reference für den Messaging Service herbekommen?
		messagingService = new DummyMessagingService();
		
		Channel geoPosChannel = messagingService.channel(GeographicPosition.class.getSimpleName());
		
		geoPosChannel.subscribeConsumer(this::consumeGeoPosition);
	}
	
	private void consumeGeoPosition(Channel c, Object data) {
		GeographicPosition pos = (GeographicPosition) data;
		
		createUserTraceIfNotExistent();
		userTraces.put(pos.userId, pos);
	}
	
	private void createUserTraceIfNotExistent(Long uid) {
		if(!userTraces.containsKey(uid)) {
			userTraces.put(uid, new ArrayDeque<>(20));
		}
	}
	
	private void appendTrace(Long userId, GeographicPosition pos) {
		createUserTraceIfNotExistent();
		userTraces.get(userId).add(pos);
	}
	}

	private HotPlace[] findHotPlacesForUserTrace(GeographicPosition[] trace) {
		// TODO: Hier müsste die Bewegung (Richtungsvektor?) des Benutzers betrachtet werden und interessante Orte gefiltert werden
		return null;
	}
}