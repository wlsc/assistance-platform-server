package de.tudarmstadt.informatik.tk.assistanceplatform.modules.hotplaces.data;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Deque;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Stream;

import de.tudarmstadt.informatik.tk.assistanceplatform.data.GeographicPosition;
import de.tudarmstadt.informatik.tk.assistanceplatform.modules.DataModule;
import de.tudarmstadt.informatik.tk.assistanceplatform.modules.hotplaces.HotPlace;
import de.tudarmstadt.informatik.tk.assistanceplatform.services.messaging.MessagingService;
import de.tudarmstadt.informatik.tk.assistanceplatform.services.messaging.MessagingService.Channel;

/**
 * This module does the data processing for the hot place detections and recommendations.
 * @author bjeutter
 */
public class HotPlacesDataModule extends DataModule {
	private List<GeographicPosition> geoPosDB = new ArrayList<>();
	
	private Map<Long, Deque<GeographicPosition>> userTraces = new HashMap<>();
	
	public HotPlacesDataModule(MessagingService messagingService) {
		super();
		
		Channel geoPosChannel = messagingService.channel(GeographicPosition.class.getSimpleName());
		
		geoPosChannel.subscribeConsumer(this::consumeGeoPosition);
	}
	
	private void consumeGeoPosition(Channel c, Object data) {
		GeographicPosition pos = (GeographicPosition) data;
		geoPosDB.add(pos);
		appendTrace(pos);
		
		// TODO: Only find hot places when user not busy
		
		HotPlace[] places = findHotPlacesForUserTrace(userTraces.get(pos.userId));
	}
	
	private void appendTrace(GeographicPosition pos) {
		Long uid = pos.userId;
		createUserTraceIfNotExistent(uid);
		userTraces.get(uid).add(pos);
	}

	private void createUserTraceIfNotExistent(Long uid) {
		if(!userTraces.containsKey(uid)) {
			userTraces.put(uid, new ArrayDeque<>(20));
		}
	}

	private HotPlace[] findHotPlacesForUserTrace(Collection<GeographicPosition> trace) {
		double avgLat = trace.parallelStream().mapToDouble(c -> c.latitude).average().getAsDouble();
		double avgLong = trace.parallelStream().mapToDouble(c -> c.longitude).average().getAsDouble();
		
		GeographicPosition avgPos = new GeographicPosition(-1, avgLat, avgLong);
		
		Stream<GeographicPosition> nearPositions = geoPosDB.parallelStream().filter(p -> p.distance(avgPos) < 500);
		
		Map<String, Integer> geoPosCount = new HashMap<>();
		
		nearPositions.forEach(geo -> {
			String g = geo.latitude+";"+geo.longitude;
			Integer counter = geoPosCount.get(g);
			
			if(counter == null) {
				counter = 0;
			}
			
			counter++;
			
			geoPosCount.put(g, counter);
		});
		
		HotPlace[] hotPlaces;
		
		Object[] test = geoPosCount.entrySet()
		.parallelStream()
		.filter(e -> e.getValue() > 10)
		.sorted((a, b) -> b.getValue().compareTo(a.getValue()))
		.limit(10).map(e -> new HotPlace( nearPositions.filter(g -> (g.latitude+";"+g.longitude).equals(e.getKey())).findFirst()).toArray();
		
		if(test.length > 0) {
			int i = 1;
			i-= 1;
		}
		
		// TODO: Hier m√ºsste die Bewegung (Richtungsvektor?) des Benutzers betrachtet werden und interessante Orte gefiltert werden
		return null;
	}
}