package de.tudarmstadt.informatik.tk.assistanceplatform.modules.hotplaces.data;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Deque;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import de.tudarmstadt.informatik.tk.assistanceplatform.data.GeographicPosition;
import de.tudarmstadt.informatik.tk.assistanceplatform.modules.DataModule;
import de.tudarmstadt.informatik.tk.assistanceplatform.modules.hotplaces.HotPlace;
import de.tudarmstadt.informatik.tk.assistanceplatform.services.messaging.MessagingService;
import de.tudarmstadt.informatik.tk.assistanceplatform.services.messaging.MessagingService.Channel;

/**
 * This module does the data processing for the hot place detections and recommendations.
 * @author bjeutter
 */
public class HotPlacesDataModule extends DataModule {
	private List<GeographicPosition> geoPosDB = new ArrayList<>();
	
	private Map<Long, Deque<GeographicPosition>> userTraces = new HashMap<>();
	
	public HotPlacesDataModule(MessagingService messagingService) {
		super();
		
		Channel geoPosChannel = messagingService.channel(GeographicPosition.class.getSimpleName());
		
		geoPosChannel.subscribeConsumer(this::consumeGeoPosition);
	}
	
	private void consumeGeoPosition(Channel c, Object data) {
		GeographicPosition pos = (GeographicPosition) data;
		geoPosDB.add(pos);
		appendTrace(pos);
		
		HotPlace[] places = findHotPlacesForUserTrace(userTraces.get(pos.userId));
	}
	
	private void appendTrace(GeographicPosition pos) {
		Long uid = pos.userId;
		createUserTraceIfNotExistent(uid);
		userTraces.get(uid).add(pos);
	}

	private void createUserTraceIfNotExistent(Long uid) {
		if(!userTraces.containsKey(uid)) {
			userTraces.put(uid, new ArrayDeque<>(20));
		}
	}

	private HotPlace[] findHotPlacesForUserTrace(Collection<GeographicPosition> trace) {
		double avgLat = trace.parallelStream().mapToDouble(c -> c.latitude).average().getAsDouble();
		double avgLong = trace.parallelStream().mapToDouble(c -> c.longitude).average().getAsDouble();
		
		GeographicPosition avgPos = new GeographicPosition(-1, avgLat, avgLong);
		
		GeographicPosition nearPositions = geoPosDB.parallelStream().filter(p -> p.distance(avgPos) < 500);
		
		// TODO: Hier mÃ¼sste die Bewegung (Richtungsvektor?) des Benutzers betrachtet werden und interessante Orte gefiltert werden
		return null;
	}
}